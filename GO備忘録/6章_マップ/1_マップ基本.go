package main

import "fmt"

/*
マップは、キーと値を1つのペアとして保存するデータ構造です。
「見出し(キー)がついてる辞書」や「名前の付いた引き出し」のようなものです。

以下の特徴を抑えておきましょう。

・ キーと値のペア：  map[キーの型]値の方　のように宣言します。

・ キーの一意性： 　マップ内のキーは重複できません。同じキーで値を設定すると、新しい値で上書きされます。

・ 高速な検索:     配列やスライスがインデックスで値を探すのに対し、マップはキーを使って直接探すためデータ量が増えても検索速度が落ちにくいです。

・ 順序は保証されない: マップに追加した要素の順序は、取り出す際に保証されません。Goのバージョンによっては順序がランダムになることもあります。

・ 参照型:         スライスと同様に、マップも参照型です。関数に渡す際にデータ全体がコピーされず効率的です。また、可変長という特徴を持っています。
*/

func main() {
	// string型のキーと、int型の値を持つマップを作成
	// make(map[キーの型]値の型) で初期化するのが一般的です。
	scores := make(map[string]int)
	fmt.Println(scores) // map[] この段階では当然空です

	// マップにキーと値のペアを追加
	scores["国語"] = 85
	scores["数学"] = 92
	scores["英語"] = 78

	fmt.Println(scores) // map[国語:85 数学:92 英語:78]

	// マップにキーと値のペアを更新
	scores["数学"] = 100
	fmt.Println(scores) // map[国語:85 数学:100 英語:78]

	// キーを指定して値を取得
	mathScore := scores["数学"]
	fmt.Printf("数学の点数: %d\n", mathScore) // 数学の点数: 100

	// 宣言と同時に初期化もできる（リテラル構文）
	users := map[int]string{
		1: "山田",
		2: "佐藤",
		3: "鈴木",
	}
	fmt.Println(users) // map[1:山田 2:佐藤 3:鈴木]

	// delete関数で要素を削除
	delete(users, 2)           // キーが2の要素（佐藤）を削除
	fmt.Println("削除後:", users) // map[1:山田 3:鈴木]
}
