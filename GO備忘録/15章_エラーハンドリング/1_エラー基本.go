/*Goのエラーハンドリング哲学-エラーはただの値である。

多くの言語では、エラーは「例外(Exception)」として扱われ、特別な仕組み(try-catch)で捕捉されます。

しかし、Goでは、**エラーは特別なものではなく、関数の戻り値として返されるための「値」である**という考え方をします。
エラーが発生する可能性があるということは、プログラムの正常な流れの一部で、例外的なことではないという思想です。

これにより、プログラマはエラーの発生を常に意識し、コードのどこでエラーが起こりうるか、そしてそれをどう処理するかが明確になります。
*/

/*error型 -Goのエラーの正体
  Goのエラーは、errorという組み込みのインターフェースで表現されます。
  このインターフェースは非常にシンプルで、たった1つだけメソッドを要求します。
*/
type error interface {
	Error() string
}
// つまり、Error()というメソッドを持っていて、それがstringを返せば、どんな型でもerrorとして扱えます。

/* Goの定石: (値, error)のペアを返す
   Goのプログラミングで最も頻繁に目にするのが、このパターンです。
   エラーを発生させる可能性のある関数は、戻り値として「本来の結果」と「error」の2つを返します。

   ・成功した場合: (結果の値, nil)を返します。errorがnilであれば、成功したと判断します。
   ・失敗した場合: (結果のゼロ値, errorオブジェクト)を返します。errorがnil出なければ、失敗したと判断します。

   そして、関数を呼び出した側は、戻り値をすぐにチャックするのが鉄則です。
*/

if err != nil {
	fmt.Println("エラーが発生しました:", err)
}

// もしエラーがnilでなければ(つまりエラーがあれば)というチェックは、Goのコードを書く上で呼吸をするのと同じくらい自然におこなうべき基本動作です。