package main

import "fmt"

/*
スライスは、配列の使い勝手を大幅に向上させたもので、
長さを自由に変更できる、配列への参照のようなものです。つまり可変長です。
Goではこのスライスをよく使います。

以下の特徴を抑えておきましょう。

・可変長。 append関数(後述)で自由に要素を追加できます。

・参照型のようなふるまい。 スライスは内部的に、
1.土台となる配列へのポインタ
2.長さ
3.容量
の情報を持っています。

・効率的。 関数に渡されるのはこの3つの情報を持つ小さなヘッダ部分だけです。
データー本体はコピーされないため、非常に効率的です。
*/

func main() {
	// スライスの宣言(配列と違い、可変長であるため長さは書きません)
	s := []int{10, 20, 30}
	fmt.Printf("型: %T, 値: %v\n", s, s)           // 型: []int, 値: [10 20 30]
	fmt.Printf("長さ: %d, 容量: %d", len(s), cap(s)) // 長さ: 3, 容量: 3

	// append関数を使って要素を追加してみましょう
	s = append(s, 40)
	fmt.Println(s) // [10 20 30 40]

	// Python等と比較すると複雑に見えますが、
	// 例えば[1,2]のリストに3をappendしたいとき、[1,2] + [3]としているようなものです。

	s = append(s, 50, 60)
	fmt.Println(s)                               // [10 20 30 40 50 60]
	fmt.Printf("長さ: %d, 容量: %d", len(s), cap(s)) // 長さ: 6, 容量: 6
	// 長さ: 6, 容量: 6  ということで、自動で容量が拡張されていることがわかります。

	// スライスから一部を切り出す(スラッシング)
	part := s[1:3]            // 1から3未満の要素を切り出す
	fmt.Println("part", part) // part [20 30]
}
